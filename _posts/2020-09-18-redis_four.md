---
layout: post
title: Redis（四），缓存
categories: [数据库]
---

Redis缓存了数据，为数据库分担压力

<!-- more -->
### 缓存穿透
1. 一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找。  
一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力

2. 解决方案：
   1. 布隆过滤器。将所有可能存在的key哈希到一个足够大的bitmap中，一定查询不到的数据会被拦截
   2. 短暂缓存空对象
   
### 缓存击穿
1. 一个key非常地热点，扛着超高的并发，当这个key失效的瞬间，持续的高并发就穿透了缓存，直接访问数据库，导致数据库瘫痪

2. 解决方案：
   1. 写入redis时不设置过期时间。设置逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存
   2. 互斥锁。一个key返回空，同时只有一个线程去查询数据库

### 缓存雪崩
1. 缓存层挂断或者短暂时间内大量key失效，请求全部到达存储层，可能导致存储层挂掉

2. 解决方案：
   1. 搭建高可用缓存集群
   2. 限流降级。缓存失效后，通过分布式锁或者分布式队列对数据库的读写进行限制
   3. 数据预热。将可能的数据进行预访问，并设置尽量均匀的失效时间

### 缓存的并发竞争
1. 多客户端并发读写一个key

2. 解决方案：
   1. 分布式锁。确保同一时间，只能有一个系统实例在操作某个key
   2. 判断时间戳。当前时间戳比缓存内的时间戳靠后，则当前数据不进行更新操作